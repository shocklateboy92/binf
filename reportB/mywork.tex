\chapter{Design \& Implementation}

\section{Initialization}
Since iHMMuneAlign is rather configurable, it requires a large amount of input data for each run that cannot be embedded in the code directly. This data has to be read during program initialisation and stored in memory such that it can be efficiently used in their required of the algorithm.
\subsection{D/J Repertoires}
\subsection{V Repertoire}
\subsection{Mutation Ratios}

\section{Pipeline}

\begin{figure}
	\label{fig:pipeline}
	\caption{Overview of the Model Solving `Pipeline'}
	\centering
	\begin{dot2tex}
		digraph G {

			{
				1;
				2;
				3;
				4;
			}

			{
				node[color=none];
				"Input Sequence" -> 1;
				"BLAST Hit" -> 1;

				1 -> "A Score" -> 2;

				2 -> "States" -> 3;
				2 -> "Transitions" -> 3;

				3 -> "Most Likely Path" -> 4;
				4 -> "Output";
			}
		}
	\end{dot2tex}
\end{figure}

The entire process of creating a HMM to represent \igh recombination and solving it using Viterbi's algorithm can be split up into several smaller problems. These can be viewed as stages in an assembly line where the result of each one feeds into the next, terminating with the final result. In computing, this is called a pipeline.

\subsection{BLAST}
The first step is to determine the most likely germline V gene is in the target sequence. Fortunately, this can be determined quite efficiently by aligning the input sequence with all known V genes \cite{iHMMuneAlign}. For that we opted to use the excellent alignment tool by NCBI: BLAST \cite{blast}, like the original implementation.

BLAST is distributed as source code, and can be used in two ways:
\subsubsection{Invoking Binary}
There are binaries for all the common tasks, that take in sequence repertoires as files in FASTA \autocite{fasta} format. The previous implementation used the \code{blastn} executable, which takes in a sequence in FASTA format, and writes the results (matching sequences in the repertoires) out to an XML file.

The primary advantage of using blast in this manner would be the ease of development. Since the binaries come pre-packaged, very little extra code would be required to invoke the binary from within iHMMuneAlign, and parse the XML output. However, doing so incurs a (potentially significant) performance penalty at run time due to the cost of

\begin{description}
	\item[Process Creation]
	The operating system has to create a new process for the blast executable, perform all its bookkeeping operations, and clean up after it is completed.
	\item[Reading Input Files]
	The executable would then have to read the database files from disk again, instead of using the copy that already in memory (residing in iHMMuneAlign's address space).
	\item[Serialising Results]
	Once the blast executable completes its alignment search, it will then need to convert that data into a human readable, or standardised format that can be parsed by iHMMuneAlign.
	\item[Transferring Results]
	disk, ipc
\end{description}

\subsubsection{Linking Shared Library}
BLAST+ can be 

\subsection{Parsing Blast Results}
\subsection{Calculating A-Score}
\subsection{Generating Model}
\subsubsection{Generating V/D/J States}
\subsubsection{Generating Transitions}
\subsection{Running Viterbi}
\subsection{Printing Results}


\section{Approach}
Talk about agile here.

\chapter{Maintenance}
Talk about how I attempted to improve maintainability/readability here

\section{Revision Control}
Explain how revision control will help future maintenance 

\chapter{Performance}
Talk about how I set off to improve performance here

\section{Blast Lib}
