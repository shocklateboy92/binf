@article{iHMMuneAlign,
author = {Gaëta, Bruno A. and Malming, Harald R. and Jackson, Katherine J.L. and Bain, Michael E. and Wilson, Patrick and Collins, Andrew M.}, 
title = {iHMMune-align: hidden Markov model-based alignment and identification of germline genes in rearranged immunoglobulin gene sequences},
volume = {23}, 
number = {13}, 
pages = {1580-1587}, 
year = {2007}, 
doi = {10.1093/bioinformatics/btm147}, 
abstract ={Motivation: Immunoglobulin heavy chain (IGH) genes in mature B lymphocytes are the result of recombination of IGHV, IGHD and IGHJ germline genes, followed by somatic mutation. The correct identification of the germline genes that make up a variable VH domain is essential to our understanding of the process of antibody diversity generation as well as to clinical investigations of some leukaemias and lymphomas.Results: We have developed iHMMune-align, an alignment program that uses a hidden Markov model (HMM) to model the processes involved in human IGH gene rearrangement and maturation. The performance of iHMMune-align was compared to that of other immunoglobulin gene alignment utilities using both clonally related and randomly selected IGH sequences. This evaluation suggests that iHMMune-align provides a more accurate identification of component germline genes than other currently available IGH gene characterization programs.Availability: iHMMune-align cross-platform Java executable and web interface are freely available to academic users and can be accessed at http://www.emi.unsw.edu.au/~ihmmune/Contact: bgaeta@cse.unsw.edu.au}, 
URL = {http://bioinformatics.oxfordjournals.org/content/23/13/1580.abstract}, 
eprint = {http://bioinformatics.oxfordjournals.org/content/23/13/1580.full.pdf+html}, 
journal = {Bioinformatics} 
}

@online{jni,
author = {Oracle},
title = {Java Native Interface Specification},
year = {2014},
url = {http://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html},
OPTsubtitle = {•},
OPTtitleaddon = {•},
OPTlanguage = {•},
OPTversion = {•},
OPTnote = {•},
OPTorganization = {•},
OPTdate = {•},
OPTmonth = {•},
OPTaddendum = {•},
OPTpubstate = {•},
OPTurldate = {•},
}

@article{cpp,
  title={Technical report on C++ performance},
  author={Goldthwaite, Lois},
  journal={ISO/IEC PDTR},
  volume={18015},
  year={2006}
}

@incollection{fasta,
year={1994},
isbn={978-0-89603-246-0},
booktitle={Computer Analysis of Sequence Data},
volume={24},
series={Methods in Molecular Biology},
editor={Griffin, AnnetteM. and Griffin, HughG.},
doi={10.1385/0-89603-246-9:307},
title={Using the FASTA Program to Search Protein and DNA Sequence Databases},
url={http://dx.doi.org/10.1385/0-89603-246-9%3A307},
publisher={Humana Press},
author={Pearson, WilliamR.},
pages={307-331},
language={English}
}

@article{qtvjava,
  title={A comparison of qt and java for large-scale, industrial-strength gui development},
  author={Dalheimer, Matthias Kalle},
  journal={Klarlvdalens Datakonsult AB, Tech. Rep},
  year={2005}
}

@article{bpp,
  title={Bio++: a set of C++ libraries for sequence analysis, phylogenetics, molecular evolution and population genetics},
  author={Dutheil, Julien and Gaillard, Sylvain and Bazin, Eric and Gl{\'e}min, Sylvain and Ranwez, Vincent and Galtier, Nicolas and Belkhir, Khalid},
  journal={BMC bioinformatics},
  volume={7},
  number={1},
  pages={188},
  year={2006},
  publisher={BioMed Central Ltd}
}

@article{biojava,
author = {Holland, R. C. G. and Down, T. A. and Pocock, M. and Prlić, A. and Huen, D. and James, K. and Foisy, S. and Dräger, A. and Yates, A. and Heuer, M. and Schreiber, M. J.}, 
title = {BioJava: an open-source framework for bioinformatics},
volume = {24}, 
number = {18}, 
pages = {2096-2097}, 
year = {2008}, 
doi = {10.1093/bioinformatics/btn397}, 
abstract ={Summary: BioJava is a mature open-source project that provides a framework for processing of biological data. BioJava contains powerful analysis and statistical routines, tools for parsing common file formats and packages for manipulating sequences and 3D structures. It enables rapid bioinformatics application development in the Java programming language.Availability: BioJava is an open-source project distributed under the Lesser GPL (LGPL). BioJava can be downloaded from the BioJava website (http://www.biojava.org). BioJava requires Java 1.5 or higher.Contact: andreas.prlic@gmail.com. All queries should be directed to the BioJava mailing lists. Details are available at http://biojava.org/wiki/BioJava:MailingLists.}, 
URL = {http://bioinformatics.oxfordjournals.org/content/24/18/2096.abstract}, 
eprint = {http://bioinformatics.oxfordjournals.org/content/24/18/2096.full.pdf+html}, 
journal = {Bioinformatics} 
}

@article{biojava3,
author = {Prlić, Andreas and Yates, Andrew and Bliven, Spencer E. and Rose, Peter W. and Jacobsen, Julius and Troshin, Peter V. and Chapman, Mark and Gao, Jianjiong and Koh, Chuan Hock and Foisy, Sylvain and Holland, Richard and Rimša, Gediminas and Heuer, Michael L. and Brandstätter–Müller, H. and Bourne, Philip E. and Willis, Scooter}, 
title = {BioJava: an open-source framework for bioinformatics in 2012},
volume = {28}, 
number = {20}, 
pages = {2693-2695}, 
year = {2012}, 
doi = {10.1093/bioinformatics/bts494}, 
abstract ={Motivation: BioJava is an open-source project for processing of biological data in the Java programming language. We have recently released a new version (3.0.5), which is a major update to the code base that greatly extends its functionality.Results: BioJava now consists of several independent modules that provide state-of-the-art tools for protein structure comparison, pairwise and multiple sequence alignments, working with DNA and protein sequences, analysis of amino acid properties, detection of protein modifications and prediction of disordered regions in proteins as well as parsers for common file formats using a biologically meaningful data model.Availability: BioJava is an open-source project distributed under the Lesser GPL (LGPL). BioJava can be downloaded from the BioJava website (http://www.biojava.org). BioJava requires Java 1.6 or higher. All inquiries should be directed to the BioJava mailing lists. Details are available at http://biojava.org/wiki/BioJava:MailingListsContact: andreas.prlic@gmail.com}, 
URL = {http://bioinformatics.oxfordjournals.org/content/28/20/2693.abstract}, 
eprint = {http://bioinformatics.oxfordjournals.org/content/28/20/2693.full.pdf+html}, 
journal = {Bioinformatics} 
}

@book{boost-book,
 author = {Schling, Boris},
 title = {The Boost C++ Libraries},
 year = {2011},
 isbn = {0982219199, 9780982219195},
 publisher = {XML Press},
}

@article{boost,
  title={Boost C++ libraries},
  author={Dawes, Beman and Abrahams, David and Rivera, Rene},
  journal={URL http://www. boost. org},
  volume={35},
  pages={36},
  year={2009}
}

@book{stl,
 author = {Musser, David R. and Derge, Gillmer J. and Saini, Atul},
 title = {STL Tutorial and Reference Guide: C++ Programming with the Standard Template Library},
 year = {2009},
 isbn = {0321702123, 9780321702128},
 edition = {3rd},
 publisher = {Addison-Wesley Professional},
}

@article{freelunch,
  title={The free lunch is over: A fundamental turn toward concurrency in software},
  author={Sutter, Herb},
  journal={Dr. Dobb’s journal},
  volume={30},
  number={3},
  pages={202--210},
  year={2005}
}

@INPROCEEDINGS{jit, 
author={Krall, A.}, 
booktitle={Parallel Architectures and Compilation Techniques, 1998. Proceedings. 1998 International Conference on}, 
title={Efficient JavaVM just-in-time compilation}, 
year={1998}, 
month={Oct}, 
pages={205-212}, 
abstract={Conventional compilers are designed for producing highly optimized code without paying much attention to compile time. The design goals of Java just-in-time compilers are different: produce fast code at the smallest possible compile time. In this article we present a very fast algorithm for translating JavaVM byte code to high quality machine code for RISC processors. This algorithm handles combines instructions, does copy elimination and coalescing and does register allocation. It comprises three passes: basic block determination, stack analysis and register preallocation, final register allocation and machine code generation. This algorithm replaces an older one in the CACAO JavaVM implementation reducing the compile time by a factor of seven and producing slightly faster machine code. The speedup comes mainly from following simplifications: fixed assignment of registers at basic block boundaries, simple register allocator better exception handling better memory management and fine tuning the implementation. The CACAO system is currently faster than every JavaVM implementation for the Alpha processor and generates machine code for all used methods of the javac compiler and its libraries in 60 milliseconds on an Alpha workstation}, 
keywords={parallel programming;program compilers;CACAO system;JavaVM;JavaVM implementation;RISC processors;block determination;compilers;just-in-time compilation;native code compilation;register allocation;register preallocation;stack analysis;Computer languages;Internet;Java;Memory management;Page description languages;Read only memory;Reduced instruction set computing;Registers;Sun;Virtual machining}, 
doi={10.1109/PACT.1998.727250}, 
ISSN={1089-795X},}
